* general config

Make org-mode the defualt file mode
#+BEGIN_SRC emacs-lisp
  (setq-default major-mode 'org-mode)
#+END_SRC

This will remove any trailing whitespace on save
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Let the yank command access the last thing copied to the system
clipboard
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard t
      select-enable-primary t
      save-interprogram-paste-before-kill t)
#+END_SRC

Let the apropos help search include non-interactive functions in its
search
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)
#+END_SRC

Flash top and bottom bars of the screen as an alert
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

Set the maximum length of a string printed by evaluating a function to
unlimited. (I had to set this to fix some annoying behavior when
evaluating elisp functions).
#+BEGIN_SRC emacs-lisp
(setq eval-expression-print-length nil)
#+END_SRC

Use ido-mode for finding files and buffers. Enabling flex matching
will make it a fuzzy search.
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
  (setq ido-enable-flex-matching t)
#+END_SRC

Auto-saved files should be saved to '~/.emacs.d/auto-save/'. This
obviously requires this directory to be in place.
#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(concat user-emacs-directory "auto-save/") t)))
#+END_SRC

* global keybindings

Use helm for function search
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-M-x)
#+END_SRC

Set the magit bindings recommended in the magit tutorial
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x g") 'magit-status)
(global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

I missed Vi's "o" button which would jump to the next line without
breaking the current line. So I wrote a function to do that and mapped
it to C-o. The function is defined in the custom functions section.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-o") 'jump-to-newline)
#+END_SRC

Use hippie-expand instead of the default expand. It will rotate
through many different expansion options. Can be a little much at
times.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

Set M-SPC to cyle through spaces between characters (alternating
between no space, one space, and however many spaces it is
currently). This can be used as a quick way to delete extra whitespace
#+BEGIN_SRC
(global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

* text-mode

Turn on auto-fill mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

* prog-mode

prog mode is the super class of every programming language mode

require the linum-relative package which enables relative line
numbers. I've commented this out because use-package is erroring out.
#+BEGIN_SRC emacs-lisp
;;  (use-package linum-relative
;;               :ensure t)
#+END_SRC

turn on absolute line numbers. (I'm still working out the kinks with
relative-line numbers)
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda () (linum-mode)))
#+END_SRC

require a final \n character at the end of the file
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda ()
                              (setq require-final-newline t)))
#+END_SRC


Highlight characters in the 80th column in red. Shadows the font-face
color set in the package.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda ()
                              (defface column-marker-1 '((t (:background "red")))
    "Face used for a column marker.  Usually a background color."
                              :group 'faces)
                              (column-marker-1 80)))
#+END_SRC

* org-mode

Set keys that were supposed to be already set in org-mode, but for
some reason were not set for me by default.
#+BEGIN_SRC emacs-lisp
  (defun my-org-mode-config ()
    (local-set-key (kbd "C-M-j") 'org-insert-heading)
    (local-set-key (kbd "C-<RET>") 'org-insert-heading-respect-content))
  (add-hook 'org-mode-hook 'my-org-mode-config)
#+END_SRC

Specify which languages org-mode can execute (by C-c C-c'ing with the
cursor over a code-block). Org-mode can execute many languages, but it
only can execute emacs lisp by defualt, and the rest must be
explicitly enabled. At the moment this only explicitly enables shell
(bash) and ruby.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sh . t)
     (ruby . t)))
#+END_SRC

* smart-parens-mode
The default slurping and barfing commands were being captured by my
terminal before smart parens mode could get them. This remapping
fixed that.
#+BEGIN_SRC emacs-lisp
  (defun my-smartparens-mode-config ()
    "map slurping and barfing (because the default C-M-<right>/<left> were being capture by the terminal)"
    (local-set-key (kbd "M-<right>") 'sp-backward-barf-sexp)
    (local-set-key (kbd "M-<left>") 'sp-backward-slurp-sexp))

  (add-hook 'smartparens-mode-hook 'my-smartparens-mode-config)
#+END_SRC

* web-mode
I prefer web-mode to whatever the default mode was for dealing with
html.

Require web-mode. I've commented this out because use-package is
erroring out
#+BEGIN_SRC emacs-lisp
;;  (use-package web-mode
;;    :ensure t)
#+END_SRC

Set various file-types to invoke web-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
#+END_SRC

The default indenting was too much for me, so I set it to 2 spaces.
#+BEGIN_SRC emacs-lisp
  (setq web-mode-markup-indent-offset 2)
#+END_SRC

* whitespace-mode
  For a while I thought I wanted to customize whitespace-mode and
  start using it for programming. But I quickly realized that all I
  really wanted to do was to automatically eliminate trailing
  whitespace.

This is about as far as I got into customizing whitespace-mode. I
don't remember what it does, but I'm sure it's great.
#+BEGIN_SRC emacs-lisp
  (setq whitespace-style '(face trailing empty))
#+END_SRC

* config for Ruby

Require enh-ruby-mode.
#+BEGIN_SRC emacs-lisp
;;  (use-package enh-ruby-mode
;;               :ensure t)
#+END_SRC

Use enh-ruby-mode instead of ruby-mode. Among other things, it has
  better detection of syntax errors.
#+BEGIN_SRC emacs-lisp
  (add-to-list
   'auto-mode-alist
   '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
#+END_SRC

Adds a function to be run with enh-ruby-mode which:
- Sets "C-o" to jump to a new line
- creates "M-x insert-pry" command which will insert "require 'pry';
  binding.pry". (This will cause the ruby interpreter to start the pry
  repl in the context of this line).
#+BEGIN_SRC emacs-lisp
  (defun my-enh-ruby-mode-config ()
    (local-set-key (kbd "C-o") 'jump-to-newline)
    (fset 'insert-pry
          (lambda (&optional arg)
            "Keyboard macro."
            (interactive "p")
            (kmacro-exec-ring-item
             (quote ("require 'pry'; binding.pry" 0 "%d"))
             arg))))

  (add-hook 'enh-ruby-mode-hook 'my-enh-ruby-mode-config)
#+END_SRC

Adds a hook to start ruby electric mode. Ruby electric mode will
auto-complete brackets, parens, and do-end blocks.
#+BEGIN_SRC emacs-lisp
  (add-hook 'enh-ruby-mode-hook 'ruby-electric-mode)
#+END_SRC

Overshadow the ruby-electric-curlies function defined in
ruby-electric-mode. I added a slight modification to the function to
put the cursor in between the curly braces, padded with a space on
either side (like "{ X }").
#+BEGIN_SRC emacs-lisp
  (defun ruby-electric-mode-config ()
   (defun ruby-electric-curlies (arg)
     (interactive "*P")
     (ruby-electric-insert
      arg
      (cond
       ((ruby-electric-code-at-point-p)
        (save-excursion
          (insert "}")
          (font-lock-fontify-region (line-beginning-position) (point)))
        (cond
         ((ruby-electric-string-at-point-p) ;; %w{}, %r{}, etc.
          (if region-beginning
              (forward-char 1)))
         (ruby-electric-newline-before-closing-bracket
          (cond (region-beginning
                 (save-excursion
                   (goto-char region-beginning)
                   (newline))
                 (newline)
                 (forward-char 1)
                 (indent-region region-beginning (line-end-position)))
                (t
                 (insert " ")
                 (save-excursion
                   (newline)
                   (ruby-indent-line t)))))
         (t
          (if region-beginning
              (save-excursion
                (goto-char region-beginning)
                (insert " "))
            (insert " "))
          (insert " ")
          (backward-char)
          (and region-beginning
               (forward-char 1)))))
       ((ruby-electric-string-at-point-p)
        (let ((start-position (1- (or region-beginning (point)))))
          (cond
           ((char-equal ?\# (char-before start-position))
            (unless (save-excursion
                      (goto-char (1- start-position))
                      (ruby-electric-escaped-p))
              (insert "}")
              (or region-beginning
                  (backward-char 1))))
           ((or
             (ruby-electric-command-char-expandable-punct-p ?\#)
             (save-excursion
               (goto-char start-position)
               (ruby-electric-escaped-p)))
            (if region-beginning
                (goto-char region-beginning))
            (setq this-command 'self-insert-command))
           (t
            (save-excursion
              (goto-char start-position)
              (insert "#"))
            (insert "}")
            (or region-beginning
                (backward-char 1))))))
       (t
        (delete-char -1)
        (ruby-electric-replace-region-or-insert))))))
#+END_SRC

Add a hook so that when ruby-electric-mode starts, the
ruby-electric-curlies function will be overshadowed. Without doing
this the packaged version of the function takes precedence.
#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-electric-mode-hook 'ruby-electric-mode-config)
#+END_SRC

I this fix from https://github.com/pezra/rspec-mode is supposed to fix
a bug where rspec runs in zshell and doesn't work. I'm not sure if
it's actually helping me or not, as I haven't put much time into
getting rspec running in emacs.
#+BEGIN_SRC emacs-lisp
  (defadvice rspec-compile (around rspec-compile-around)
    "Use BASH shell for running the specs because of ZSH issues."
    (let ((shell-file-name "/bin/bash"))
      ad-do-it))
  (ad-activate 'rspec-compile)
#+END_SRC

* config for Clojure

Require cider-mode. Cider-mode will evaluate clojure in a repl.  I've commented this out because use-package is
erroring out
#+BEGIN_SRC emacs-lisp
;;  (use-package cider-mode
;;               :ensure t)
#+END_SRC

start eldoc-mode in cider-mode. Eldoc shows doc strings in the
mini-buffer.
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-mode-hook 'eldoc-mode)
#+END_SRC

Hook for rainbow-delimiters mode. Rainbow delimiters colors parens
based on nesting level.
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

Hook for show parens mode. Show parens mode will highlight the
matching paren to the paren under the cursor
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook 'show-paren-mode)
#+END_SRC

Hook for smartparens mode. Smartparens mode auto-completes parens, and
adds commands that make working with paren-heavy languages easier.
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook 'smartparens-mode)
#+END_SRC

Tell the nrepl (which cider-mode users) to log protocol messages
#+BEGIN_SRC emacs-lisp
  (setq nrepl-log-messages t)
#+END_SRC

Don't automatically open the cider repl in a new window.
#+BEGIN_SRC emacs-lisp
  (setq cider-repl-pop-to-buffer-on-connect nil)
#+END_SRC

* config for emacs lisp

Add hook for smartparens mode. (see clojure config for explanation)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'smartparens-mode)
#+END_SRC

Add hook for show parens mode (see clojure config)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'show-paren-mode)
#+END_SRC

Add hook for eldoc-mode (see clojure config)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

Add hook for rainbow delimiters mode (see clojure config)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

On saving, byte compile any .el file that already has a corrisponding
.elc file. This is to guard against someone updating the .el file but
forgetting to byte-compile it, and not having the changes take
effect.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'byte-compile-current-buffer)
#+END_SRC

* config for scheme

Start rainbow-delimiters mode with scheme
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

Start smartparens-mode with scheme.
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'smartparens-mode)
#+END_SRC

* custom functions

I wrote this because I missed Vi's "o" button which would create an
empty line below the current one, and jump to it without breaking the
current line. I may be duplicating some existing emacs command here.
#+BEGIN_SRC emacs-lisp
  (defun jump-to-newline ()
      "Move to the end of the current line, then create a newline.
  \(Like \"o\" in Vi.\) I'm probably replicating a pre-existing command."
      (interactive)
      (move-end-of-line nil)
      (newline)
      (indent-for-tab-command))
#+END_SRC

I got this function from:
http://ergoemacs.org/emacs/emacs_byte_compile.html

When in emacs-lisp-mode, this will check that a byte compiled version
of the current .el file exists, and if it does, it will
byte-compile. This is useful for keeping .el files from falling out of
date behind their byte-compiled versions.
#+BEGIN_SRC emacs-lisp
  (defun byte-compile-current-buffer ()
    "`byte-compile' current buffer if it's emacs-lisp-mode and compiled file exists."
    (interactive)
    (when (and (eq major-mode 'emacs-lisp-mode)
               (file-exists-p (byte-compile-dest-file buffer-file-name)))
      (byte-compile-file buffer-file-name)))
#+END_SRC

** org-mode spreadsheet helper functions
I wrote these functions to help with calculating my work hours and
wages in an org-mode spreadsheet. I needed these to help calculate
values in spreadsheet cells.

Adds up the minutes in hh:mm formatted time string.
#+BEGIN_SRC emacs-lisp
  (defun to-minutes (time-string)
    "Accepts a string of format '(h)h:mm' and returns total minutes"
    (string-match "\\([0-9]+\\):\\([0-9]\\{2,\\}\\)" time-string)
    (let ((hours (string-to-number (match-string 1 time-string)))
          (minutes (string-to-number (match-string 2 time-string))))
      (if (> minutes 59)
          (error (concat (number-to-string minutes) " is not between 0 and 59"))
        (+ minutes (* hours 60)))))
#+END_SRC

Takes a float representing minutes, and returns an hh:mm formatted
string.
#+BEGIN_SRC emacs-lisp
  (defun number-to-time (number)
    "Converts a float into formatted string (hh:mm)"
    (let ((hours (/ number 60))
          (minutes (% number 60)))
      (concat (format "%d" hours)
              ":"
              (format "%02d" minutes))))
#+END_SRC

Takes a list of times in the hh:mm format, and returns a sum in the same
format
#+BEGIN_SRC emacs-lisp
  (defun sum-times (time-list)
    "Takes a list of times (hh:mm), and returns sum in the same format (hh:mm)"
    (number-to-time (apply '+ (mapcar 'to-minutes time-list))))
#+END_SRC

Takes a hh:mm formatted time string, converts it to total minutes, and
  then multiplies it by an hourly rate. Returns a string formatted
  like dollars but without the "$" (because org-mode cannot read from
  a spreadsheet cell starting with "$")
#+BEGIN_SRC emacs-lisp
  (defun time-to-wage (time dollars-per-hour)
    "Converts time (hh:mm) to wages."
    (let ((minutes (to-minutes time)))
      (let ((hours (/ minutes
                      60.0)))
        (format "%0.2f" (* hours dollars-per-hour)))))
#+END_SRC

Converts a float into dollar format ($0.00)
#+BEGIN_SRC emacs-lisp
  (defun number-to-dollars (float)
    "Formats float into dollar string"
    (format "$%0.2f" float))
#+END_SRC

* novelty functions
  These were the first functions I wrote, while reading the built-in
  emacs lisp tutorial. A friend of mine loves the table-flipping meme,
  but hates emacs. So I decided to write the table-flipping meme into
  emacs.

(╯°□°)╯︵ ┻━┻
I started with this basic table-flipping character. Passing an
argument will specify how long to pause before flipping.
#+BEGIN_SRC emacs-lisp
  (defun flip-table (num)
    "Animates flipping a table."
    (interactive "p")
    (let ((start-point (point))
          (anticipation (or num 4)))
      (insert "(°-°) ┬─┬ ")
      (sit-for anticipation)
      (delete-region start-point (point))
      (insert "(╯°□°)╯︵ ┻━┻ ")))
#+END_SRC

flip-pɹoʍ︵\(°□°\)
My next function flips the last word before the cursor. A couple
required functions are also included.
#+BEGIN_SRC emacs-lisp
  (defun flip-word (num)
    "Animates flipping the last word."
    (interactive "p")
      (let ((anticipation (or num 4)))
        (re-search-backward "\\(\\<\\w+\\>[.,!?]?\\)")
        (goto-char (match-end 0))
        (insert " (°-°)")
        (let ((post-face (point)))
          (sit-for anticipation)
          (replace-match (rotate-word (match-string-no-properties 0)))
          (delete-region (match-end 0) post-face))
        (insert "︵\\(°□°\\) ")))

  (defun rotate-word (string)
    (let ((flipped))
      (dolist (ascii-dec (string-to-list string))
        (setq flipped (cons
                       (unicode-to-char
                        (dec-to-upside-down-unicode ascii-dec))
                       flipped)))
      (concat flipped)))

  ;; used in rotate-word
  (defun unicode-to-char (unicode)
    (string-to-number unicode 16))

  ;; used in rotate-word
  (defun dec-to-upside-down-unicode (dec)
    (cond ((= dec 97) "0250")
          ((= dec 98) "0071")
          ((= dec 99) "0254")
          ((= dec 100) "0070")
          ((= dec 101) "01dd")
          ((= dec 102) "025f")
          ((= dec 103) "0253")
          ((= dec 104) "0265")
          ((= dec 105) "0131")
          ((= dec 106) "027e")
          ((= dec 107) "029e")
          ((= dec 108) "006c")
          ((= dec 109) "026f")
          ((= dec 110) "0075")
          ((= dec 111) "006f")
          ((= dec 112) "0064")
          ((= dec 113) "0062")
          ((= dec 114) "0279")
          ((= dec 115) "0073")
          ((= dec 116) "0287")
          ((= dec 117) "006e")
          ((= dec 118) "028c")
          ((= dec 119) "028d")
          ((= dec 120) "0078")
          ((= dec 121) "028e")
          ((= dec 122) "007a")
          ((= dec 65) "2200")
          ((= dec 66) "10412")
          ((= dec 67) "0186")
          ((= dec 68) "15e1")
          ((= dec 69) "018e")
          ((= dec 70) "2132")
          ((= dec 71) "2141")
          ((= dec 72) "0048")
          ((= dec 73) "0049")
          ((= dec 74) "017f")
          ((= dec 75) "029e")
          ((= dec 76) "2142")
          ((= dec 77) "0057")
          ((= dec 78) "004e")
          ((= dec 79) "004f")
          ((= dec 80) "0500")
          ((= dec 81) "038c")
          ((= dec 82) "1d1a")
          ((= dec 83) "0053")
          ((= dec 84) "22a5")
          ((= dec 85) "2229")
          ((= dec 86) "039b")
          ((= dec 87) "004d")
          ((= dec 88) "0058")
          ((= dec 89) "2144")
          ((= dec 90) "005a")
          ((= dec 48) "0030")
          ((= dec 49) "21c2")
          ((= dec 50) "218a")
          ((= dec 51) "218b")
          ((= dec 52) "3123")
          ((= dec 53) "078e")
          ((= dec 54) "0039")
          ((= dec 55) "3125")
          ((= dec 56) "0038")
          ((= dec 57) "0036")
          ((= dec 38) "214b")
          ((= dec 45) "203e")
          ((= dec 63) "00bf")
          ((= dec 33) "00a1")
          ((= dec 34) "201e")
          ((= dec 39) "002c")
          ((= dec 46) "02d9")
          ((= dec 44) "0027")
          ((= dec 59) "061b")
          (t nil)))
#+END_SRC
