* general config

Use dark theme
#+BEGIN_SRC emacs-lisp
  (load-theme 'tango-dark)
#+END_SRC

Make org-mode the default file mode
#+BEGIN_SRC emacs-lisp
  (setq-default major-mode 'org-mode)
#+END_SRC

This will remove any trailing whitespace on save
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Let the yank command access the last thing copied to the system
clipboard
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard t
      select-enable-primary t
      save-interprogram-paste-before-kill t)
#+END_SRC

Let the apropos help search include non-interactive functions in its
search
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)
#+END_SRC

Flash top and bottom bars of the screen as an alert
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

Set the maximum length of a string printed by evaluating a function to
unlimited. (I had to set this to fix some annoying behavior when
evaluating elisp functions).
#+BEGIN_SRC emacs-lisp
(setq eval-expression-print-length nil)
#+END_SRC

Use ido-mode for finding files and buffers. Enabling flex matching
will make it a fuzzy search.
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
  (setq ido-enable-flex-matching t)
#+END_SRC

Auto-saved files should be saved to '~/.emacs.d/auto-save/'. This
obviously requires this directory to be in place.
#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(concat user-emacs-directory "auto-save/") t)))
#+END_SRC

set eww as the default browser to open links with
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'eww-browse-url)
#+END_SRC

remap goto-line `M-g M-g` to preview the line first
#+BEGIN_SRC emacs-lisp
  (use-package "goto-line-preview" :ensure t)
  (global-set-key [remap goto-line] 'goto-line-preview)
#+END_SRC

display column numbers alongside line numbers
#+BEGIN_SRC emacs-lisp
  (setq column-number-mode t)
#+END_SRC

** misc. required packages
packages

#+BEGIN_SRC emacs-lisp
  (use-package "dhall-mode" :ensure t)
  (use-package "simple-httpd" :ensure t)
  (use-package "yaml-mode" :ensure t)
  (use-package "restart-emacs" :ensure t)
  (use-package "sicp" :ensure t)
  (use-package "request-deferred" :ensure t)
  (use-package "undo-tree" :ensure t)
  (use-package "term-alert" :ensure t)
  (use-package "cider" :ensure t)
  (use-package "helm-ag" :ensure t)
  (use-package "mustache-mode" :ensure t)
  (use-package "groovy-mode" :ensure t)
  (use-package "leerzeichen" :ensure t)   ; a better whitespace mode
  (use-package "all-the-icons" :ensure t)
  (use-package "bug-hunter" :ensure t)
  (use-package "sparql-mode" :ensure t)
  (use-package "yaml-mode" :ensure t)
  (use-package "markdown-mode" :ensure t)
  (use-package "racket-mode" :ensure t)
  (use-package "elm-mode" :ensure t)
  (use-package "docker-tramp" :ensure t)
  (use-package "helm-tramp" :ensure t)
  (use-package "shen-mode" :ensure t)
  (use-package "harvest" :ensure t)
  (use-package "rspec-mode" :ensure t)
  (use-package "haml-mode" :ensure t)
  (use-package "rjsx-mode" :ensure t)
  (use-package "web-mode" :ensure t)
  (use-package "slime-volleyball" :ensure t)
  (use-package "clj-refactor" :ensure t)
  (use-package "rainbow-delimiters" :ensure t)
  (use-package "enh-ruby-mode" :ensure t)
  (use-package "smartparens" :ensure t)
  (use-package "magit" :ensure t)
  (use-package "helm" :ensure t)
  (use-package "cider" :ensure t)
  (use-package "term-alert" :ensure t)
  (use-package "undo-tree" :ensure t)
  (use-package "request-deferred" :ensure t)
  (use-package "sicp" :ensure t)
  (use-package "restart-emacs" :ensure t)
  (use-package "use-package" :ensure t)
  #+END_SRC

Expired packages:

#+BEGIN_SRC emacs-lisp :tangle no
   (use-package "column-marker" :ensure t)
   (use-package "markdown-mode+" :ensure t)
#+END_SRC

* macOS

for macbooks, use the command-key as meta, and the option-key as ctrl

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
     (setq mac-option-modifier 'control)
     (setq mac-command-modifier 'meta))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq helm-grep-ag-command "ag --line-numbers -S --hidden --color --color-match '31;43' --nogroup %s %s %s")
    (setq helm-grep-ag-pipe-cmd-switches '("--color-match '31;43'")))
#+END_SRC

macos has a problem that where the $PATH for gui emacs doens't match
the shell. with any luck this will fix that

#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns x))
    (and
     (not (use-package "exec-path-from-shell" :ensure t))
     (exec-path-from-shell-initialize)))
#+END_SRC

* global keybindings

Use helm for function search
#+BEGIN_SRC emacs-lisp
  (use-package "helm" :ensure t)
  (global-set-key (kbd "M-x") 'helm-M-x)
#+END_SRC

I missed Vi's "o" button which would jump to the next line without
breaking the current line. So I wrote a function to do that and mapped
it to C-o. The function is defined in the custom functions section.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-o") 'jump-to-newline)
#+END_SRC

Use hippie-expand instead of the default expand. It will rotate
through many different expansion options. Can be a little much at
times.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

Set M-SPC to cyle through spaces between characters (alternating
between no space, one space, and however many spaces it is
currently). This can be used as a quick way to delete extra whitespace
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

Sets M-m to jump to a char. Hitting the char mulitple times will keep
moving point to the next. C-M-m jumps backwards.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-m") 'iy-go-to-char)
  (global-set-key (kbd "C-M-m") 'iy-go-to-char-backward)
#+END_SRC

Use C-, to switch windows.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-,") 'other-window)
#+END_SRC

Use "helpful" menus instead of builtin help menus. These
lines copied from https://github.com/Wilfred/helpful/blob/0aa289e7a954df456793e7bc1f4bdc3d072e783f/README.md
#+BEGIN_SRC emacs-lisp
  ;; Lookup the current symbol at point. C-c C-d is a common keybinding
  ;; for this in lisp modes.
  (global-set-key (kbd "C-c C-d") #'helpful-at-point)

  ;; Look up *F*unctions (excludes macros).
  ;;
  ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
  ;; already links to the manual, if a function is referenced there.
  (global-set-key (kbd "C-h F") #'helpful-function)

  ;; Look up *C*ommands.
  ;;
  ;; By default, C-h C is bound to describe `describe-coding-system'. I
  ;; don't find this very useful, but it's frequently useful to only
  ;; look at interactive functions.
  (global-set-key (kbd "C-h C") #'helpful-command)
#+END_SRC

* buffer wrangling
  With the swap buffers package you can use `M-x swap-buffers` to move
  the current buffer to a new window.
  #+BEGIN_SRC emacs-lisp
    (use-package "swap-buffers" :ensure t)
  #+END_SRC

  since I'm using `C-,` for switching windows, I'll use `C-M-,` for
  swapping them.
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-M-,") 'swap-buffers)
  #+END_SRC
* text-mode

Turn on auto-fill mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

* prog-mode

prog mode is the super class of every programming language mode

don't allow indenting to insert tabs
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda () (setq indent-tabs-mode nil)))
#+END_SRC

require the linum-relative package which enables relative line
numbers. I've disabled this out because use-package is erroring out.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package linum-relative
               :ensure t)
#+END_SRC

turn on absolute line numbers. (I'm still working out the kinks with
relative-line numbers)
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda () (linum-mode)))
#+END_SRC

require a final \n character at the end of the file
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda ()
                              (setq require-final-newline t)))
#+END_SRC


Highlight characters in the 80th column in red. Shadows the font-face
color set in the package.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package "column-marker" :ensure t)
  (add-hook 'prog-mode-hook (lambda ()
                              (defface column-marker-1 '((t (:background "red")))
    "Face used for a column marker.  Usually a background color."
                              :group 'faces)
                              (column-marker-1 80)))
#+END_SRC

undo-tree mode makes it easier to navigate the undo history as a tree
structure.
#+BEGIN_SRC emacs-lisp
  (use-package "undo-tree" :ensure t)
  (add-hook 'prog-mode-hook 'undo-tree-mode)
#+END_SRC

* org-mode

  ensure that the C-, doesn't get over-written by org-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (local-set-key (kbd "C-,") 'other-window)))
#+END_SRC

Set keys that were supposed to be already set in org-mode, but for
some reason were not set for me by default.
#+BEGIN_SRC emacs-lisp
  (defun my-org-mode-config ()
    (local-set-key (kbd "C-M-j") 'org-insert-heading)
    (local-set-key (kbd "C-<RET>") 'org-insert-heading-respect-content))
  (add-hook 'org-mode-hook 'my-org-mode-config)
#+END_SRC

Specify which languages org-mode can execute (by C-c C-c'ing with the
cursor over a code-block). Org-mode can execute many languages, but it
only can execute emacs lisp by defualt, and the rest must be
explicitly enabled. At the moment this only explicitly enables shell
(bash) and ruby.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (ruby . t)))
#+END_SRC

Disable the warnings that prompt you when you're running elisp
source-blocks within org-mode

#+BEGIN_SRC emacs-lisp
  (defun my-org-confirm-babel-evaluate (lang body)
    (not (string= lang "emacs-lisp")))  ; don't query for elisp evaluation
  (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC

undo-tree mode makes it easier to navigate the undo history as a tree
structure.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'undo-tree-mode)
#+END_SRC

** inserting source blocks
- in the older versions of org-mode you could type `<s` followed by
  TAB to insert a code block.
- now you can bring up a menu of template to insert with `C-c C-,`

* ttl-mode
i'm not super happy with this mode. might look for an alternative. The
indentation it aggressivly-forces is annoying.

#+begin_src emacs-lisp
  (add-hook 'ttl-mode-hook 'turn-on-font-lock)
  (add-to-list 'auto-mode-alist '("\\.\\(n3\\|ttl\\|trig\\)\\'" . ttl-mode))
#+end_src

* projectile
  install both projectile and its treemacs integration
  #+BEGIN_SRC emacs-lisp
    (use-package "projectile" :ensure t)
    (use-package "treemacs-projectile" :ensure t)
  #+END_SRC

  basic treemacs setup. from https://github.com/bbatsov/projectile
  #+BEGIN_SRC emacs-lisp
    (projectile-mode +1)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  #+END_SRC

  to jump to any file in a project, use C-c p f
* smart-parens-mode

#+BEGIN_SRC emacs-lisp
  (use-package "smartparens" :ensure t)

#+END_SRC

The default slurping and barfing commands were being captured by my
terminal before smart parens mode could get them. This remapping
fixed that.
#+BEGIN_SRC emacs-lisp
  (defun my-smartparens-mode-config ()
    "map slurping and barfing (because the default C-M-<right>/<left> were being capture by the terminal)"
    (local-set-key (kbd "M-<right>") 'sp-backward-barf-sexp)
    (local-set-key (kbd "M-<left>") 'sp-backward-slurp-sexp)
    (local-set-key (kbd "M-<backspace>") 'backward-kill-word))

  (add-hook 'smartparens-mode-hook 'my-smartparens-mode-config)
#+END_SRC

By default smartparens completes single-quotes with a matching
single-quote. This is annoying because I only use smart-parens for
lisps, and lisps use unpaired single-quotes to indicate data. So I want
to disable that autocompletion.
#+BEGIN_SRC emacs-lisp
  (eval-after-load "smartparens" '(sp-pair "'" nil :actions :rem))
#+END_SRC

Also don't like it completing double-quotes
#+BEGIN_SRC emacs-lisp
  (eval-after-load "smartparens" '(sp-pair "\"" nil :actions :rem))
#+END_SRC

Also disable the auto-completion of `
#+BEGIN_SRC emacs-lisp
  (eval-after-load "smartparens" '(sp-pair "`" nil :actions :rem))
#+END_SRC

Use strict-mode.
#+BEGIN_SRC emacs-lisp
  (add-hook 'smartparens-mode-hook 'smartparens-strict-mode)
#+END_SRC

* web-mode
I prefer web-mode to whatever the default mode was for dealing with
html.

Configure pairing and auto-closing.
#+BEGIN_SRC emacs-lisp
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-pairing t)
    (setq web-mode-auto-close-style 2)
    (setq web-mode-code-indent-offset 2)
#+END_SRC

Require web-mode. I've commented this out because use-package is
erroring out
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package web-mode :ensure t)
#+END_SRC

Set various file-types to invoke web-mode
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
#+END_SRC

The default indenting was too much for me, so I set it to 2 spaces.
#+BEGIN_SRC emacs-lisp
  (setq web-mode-attr-indent-offset 2)
#+END_SRC

set "jsx" as content type with .js and .jsx files
#+BEGIN_SRC emacs-lisp
  (setq web-mode-content-types-alist
    '(("jsx" . "\\.js[x]?\\'")))
#+END_SRC

* whitespace-mode
  For a while I thought I wanted to customize whitespace-mode and
  start using it for programming. But I quickly realized that all I
  really wanted to do was to automatically eliminate trailing
  whitespace.

This is about as far as I got into customizing whitespace-mode. I
don't remember what it does, but I'm sure it's great.
#+BEGIN_SRC emacs-lisp
  (setq whitespace-style '(face trailing empty))
#+END_SRC

* dired-mode
enable all-the-icons in dired mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+END_SRC
* config for Ruby

Require enh-ruby-mode.
#+BEGIN_SRC emacs-lisp
  (use-package "enh-ruby-mode" :ensure t)
#+END_SRC

Use enh-ruby-mode instead of ruby-mode. Among other things, it has
  better detection of syntax errors.
#+BEGIN_SRC emacs-lisp
  (add-to-list
   'auto-mode-alist
   '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
#+END_SRC

Adds a function to be run with enh-ruby-mode which:
- Sets "C-o" to jump to a new line
- creates "M-x insert-pry" command which will insert "require 'pry';
  binding.pry". (This will cause the ruby interpreter to start the pry
  repl in the context of this line).
#+BEGIN_SRC emacs-lisp
  (defun my-enh-ruby-mode-config ()
    (local-set-key (kbd "C-o") 'jump-to-newline)
    (fset 'insert-pry
          (lambda (&optional arg)
            "Keyboard macro."
            (interactive "p")
            (kmacro-exec-ring-item
             (quote ("require 'pry'; binding.pry" 0 "%d"))
             arg))))

  (add-hook 'enh-ruby-mode-hook 'my-enh-ruby-mode-config)
#+END_SRC
** defunct
*** ruby-electric-mode-setup
this was all for geting ruby-electric mode working, but I don't do
much ruby anymore and it no longer seems go be in melpa

Adds a hook to start ruby electric mode. Ruby electric mode will
auto-complete brackets, parens, and do-end blocks.
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'enh-ruby-mode-hook 'ruby-electric-mode)
#+END_SRC

Overshadow the ruby-electric-curlies function defined in
ruby-electric-mode. I added a slight modification to the function to
put the cursor in between the curly braces, padded with a space on
either side (like "{ X }").
#+BEGIN_SRC emacs-lisp :tangle no
  (defun ruby-electric-mode-config ()
   (defun ruby-electric-curlies (arg)
     (interactive "*P")
     (ruby-electric-insert
      arg
      (cond
       ((ruby-electric-code-at-point-p)
	(save-excursion
	  (insert "}")
	  (font-lock-fontify-region (line-beginning-position) (point)))
	(cond
	 ((ruby-electric-string-at-point-p) ;; %w{}, %r{}, etc.
	  (if region-beginning
	      (forward-char 1)))
	 (ruby-electric-newline-before-closing-bracket
	  (cond (region-beginning
		 (save-excursion
		   (goto-char region-beginning)
		   (newline))
		 (newline)
		 (forward-char 1)
		 (indent-region region-beginning (line-end-position)))
		(t
		 (insert " ")
		 (save-excursion
		   (newline)
		   (ruby-indent-line t)))))
	 (t
	  (if region-beginning
	      (save-excursion
		(goto-char region-beginning)
		(insert " "))
	    (insert " "))
	  (insert " ")
	  (backward-char)
	  (and region-beginning
	       (forward-char 1)))))
       ((ruby-electric-string-at-point-p)
	(let ((start-position (1- (or region-beginning (point)))))
	  (cond
	   ((char-equal ?\# (char-before start-position))
	    (unless (save-excursion
		      (goto-char (1- start-position))
		      (ruby-electric-escaped-p))
	      (insert "}")
	      (or region-beginning
		  (backward-char 1))))
	   ((or
	     (ruby-electric-command-char-expandable-punct-p ?\#)
	     (save-excursion
	       (goto-char start-position)
	       (ruby-electric-escaped-p)))
	    (if region-beginning
		(goto-char region-beginning))
	    (setq this-command 'self-insert-command))
	   (t
	    (save-excursion
	      (goto-char start-position)
	      (insert "#"))
	    (insert "}")
	    (or region-beginning
		(backward-char 1))))))
       (t
	(delete-char -1)
	(ruby-electric-replace-region-or-insert))))))
#+END_SRC

Add a hook so that when ruby-electric-mode starts, the
ruby-electric-curlies function will be overshadowed. Without doing
this the packaged version of the function takes precedence.
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'ruby-electric-mode-hook 'ruby-electric-mode-config)
#+END_SRC

*** rspec integration
I haven't used rspec in a while, and if I was using it now this would
have to be different because I'm on nixos. But even then I would
probably just use something like `entr` to run my test suite.

I this fix from https://github.com/pezra/rspec-mode is supposed to fix
a bug where rspec runs in zshell and doesn't work. I'm not sure if
it's actually helping me or not, as I haven't put much time into
getting rspec running in emacs.
#+BEGIN_SRC emacs-lisp :tangle no
  (defadvice rspec-compile (around rspec-compile-around)
    "Use BASH shell for running the specs because of ZSH issues."
    (let ((shell-file-name "/bin/bash"))
      ad-do-it))
  (ad-activate 'rspec-compile)
#+END_SRC
* config for Clojure

start eldoc-mode in cider-mode. Eldoc shows doc strings in the
mini-buffer.
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-mode-hook 'eldoc-mode)
#+END_SRC

Hook for rainbow-delimiters mode. Rainbow delimiters colors parens
based on nesting level.
#+BEGIN_SRC emacs-lisp
  (use-package "rainbow-delimiters" :ensure t)
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

Hook for show parens mode. Show parens mode will highlight the
matching paren to the paren under the cursor
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook 'show-paren-mode)
#+END_SRC

Hook for smartparens mode. Smartparens mode auto-completes parens, and
adds commands that make working with paren-heavy languages easier.
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook 'smartparens-mode)
#+END_SRC

Tell the nrepl (which cider-mode users) to log protocol messages
#+BEGIN_SRC emacs-lisp
  (setq nrepl-log-messages t)
#+END_SRC

Don't automatically open the cider repl in a new window.
#+BEGIN_SRC emacs-lisp
  (setq cider-repl-pop-to-buffer-on-connect nil)
#+END_SRC

use clojure-refactor package, and set it to use dot prefix notation in requirements

#+BEGIN_SRC emacs-lisp
  (use-package "clj-refactor" :ensure t)
  (setq cljr-favor-prefix-notation nil)
#+END_SRC

** cider-sms-all-tests

   Command to run all the tests in a cider session, and send the
   results as an sms message.

*** requirements

   #+BEGIN_SRC emacs-lisp
    (use-package "dash" :ensure t)
    (use-package "cider" :ensure t)
   #+END_SRC

*** command

    Runs all tests in all namespaces connected to the current cider
    session. Sends an SMS notification to the number specified by
    `gf/sms-notification`. Contains a summary of results, and files
    with linenumbers where failures occured in the test suite.

    The lambda gets called repeatedly by the sub-process, but doesn't
    seem to have any useful data until `results` is present in `response`.

    Was written for a long-running test suite, so no command was
    written for running a single tests, or a single namespace. To
    instead run a single namespace, change `"op" "test-all"` to `"op"
    "test"`. And change `"ns" nil` to `"ns" <namespace>`.

    #+BEGIN_SRC emacs-lisp
      (defun cider-sms-all-tests ()
        "Runs all namespaces in the current running nrepl session, and sends a text
        message with the results"
        (interactive)
        (cider-nrepl-send-request `("op"      "test-all"
                                    "ns"      nil
                                    "tests"   nil
                                    "load?"   "true"
                                    "session" ,(cider-current-session))
                                  (lambda (response)
                                    (nrepl-dbind-response response (summary results)
                                      (if results
                                          (progn
                                            (let ((total (nrepl-dict-get summary "test"))
                                                  (pass (nrepl-dict-get summary "pass"))
                                                  (fail (nrepl-dict-get summary "fail"))
                                                  (failure-details (gf/file-line-context results)))
                                              (gf/sms-notification
                                               (gf/fmt-results-and-failures
                                                total
                                                pass
                                                fail
                                                failure-details)))))))))
    #+END_SRC

*** formatting

    Format the test results into a string for the SMS message.

#+BEGIN_SRC emacs-lisp
  (defun gf/fmt-results-and-failures (total pass fail failure-details)
    "Join the test summary and failures"
    (string-join
     (cons (gf/fmt-results total pass fail)
           (list (gf/fmt-failures failure-details)))
     "\n"))

  (defun gf/fmt-results (total pass fail)
    "Format test summary"
    (format "Cider Test Results: Total: %s, Passing: %s, Failing: %s" total pass fail))

  (defun gf/fmt-failures (file-line-contexts)
    "Format a list of failures as <file>:<line-number>"
    (string-join
     (cons "Failed At:"
           (-map (lambda (fl-ln-cxt)
                   (format "%s:%s" (car fl-ln-cxt) (cadr fl-ln-cxt)))
                 file-line-contexts))
     "\n"))
#+END_SRC

*** data accessors/constructors

    The `nrepl-dict.el` package provides a dict datatype that's
    returned by the cider nrepl client.

#+BEGIN_SRC emacs-lisp
  (defun gf/file-line-context (results)
    "Walk down the results tree to get file, line, and context, of each failure"
    (-flatten-n 2 (nrepl-dict-map
                   (lambda (ns vars)
                     (nrepl-dict-map
                      (lambda (_var tests)
                        (let* ((problems (cider-test-non-passing tests))
                               (count (length problems)))
                          (-map 'gf/problem->file-line-context problems)))
                      vars))
                   results)))

  (defun gf/problem->file-line-context (problem)
    "Build a list of `(file line context)`"
    (let ((file (nrepl-dict-get problem "file"))
          (line (nrepl-dict-get problem "line"))
          (context (nrepl-dict-get problem "context")))
      (list file line context)))
#+END_SRC

* config for emacs lisp

Add hook for smartparens mode. (see clojure config for explanation)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'smartparens-mode)
#+END_SRC

Add hook for show parens mode (see clojure config)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'show-paren-mode)
#+END_SRC

Add hook for eldoc-mode (see clojure config)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

Add hook for rainbow delimiters mode (see clojure config)
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

When in emacs-lisp-mode, this will check that a byte compiled version
of the current .el file exists, and if it does, it will
byte-compile. This is useful for keeping .el files from falling out of
date behind their byte-compiled versions.
#+BEGIN_SRC emacs-lisp
  (defun byte-compile-current-buffer ()
    "`byte-compile' current buffer if it's emacs-lisp-mode and compiled file exists."
    (interactive)
    (when (and (eq major-mode 'emacs-lisp-mode)
	       (file-exists-p (byte-compile-dest-file buffer-file-name)))
      (byte-compile-file buffer-file-name)))

  (add-hook 'prog-mode-hook
	    (lambda ()
	      (add-hook 'after-save-hook 'byte-compile-current-buffer nil 'make-it-local)))

#+END_SRC

* config for scheme

Start rainbow-delimiters mode with scheme
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

Start smartparens-mode with scheme.
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'smartparens-mode)
#+END_SRC

* config for coffeescript

set coffee-mode to use a tab width of 2 spaces
#+BEGIN_SRC emacs-lisp
  (add-hook 'coffee-mode-hook (lambda () (setq coffee-tab-width 2)))
#+END_SRC

* purescript
  use purescript mode and configure the indentation mode.

  #+begin_src emacs-lisp
    (use-package purescript-mode :ensure t)
    (add-hook 'purescript-mode-hook 'turn-on-purescript-indentation)
  #+end_src

  replace all instances of "forall" with "∀", but only in
  purescript-mode buffers.

  #+begin_src emacs-lisp
    (add-hook 'purescript-mode-hook
      (lambda()
	(add-hook 'before-save-hook
		  (lambda ()
		    (replace-all-in-buffer "forall" "∀")
		    (replace-all-in-buffer "->" "→")
		    (replace-all-in-buffer "=>" "⇒")
		    (replace-all-in-buffer "<-" "←")
		    (replace-all-in-buffer "::" "∷"))
		  nil t)))

    (defun replace-all-in-buffer (original new)
      "Replace all occurances of original with new."
	(save-excursion
	  (goto-char (point-min))
	  (while (re-search-forward original nil t)
	    (replace-match new))))
  #+end_src

** purescript-language-server integration
  hook the lsp mode into purescript
  #+begin_src emacs-lisp
    (add-hook 'purescript-mode-hook #'lsp)
  #+end_src

  the default cmd for starting the language server is
  `purescript-language-server --stdio`, but I'm using it by invoking
  yarn, inside a nix shell. So we need to override these variables,
  which were added in this PR:
  https://github.com/emacs-lsp/lsp-mode/pull/1596/files

  The original values, as of the time of that PR are:
  #+begin_src emacs-lisp :tangle no
    (defcustom lsp-purescript-server-executable
      "purescript-language-server"
      "Arguments to pass to the server."
      :type 'string
      :risky t
      :group 'lsp-purescript)

    (defcustom lsp-purescript-server-args
      '("--stdio")
      "Arguments to pass to the server."
      :type '(repeat string)
      :risky t
      :group 'lsp-purescript)

    (defun lsp-purescript--server-command ()
      "Generate LSP startup command for purescript-language-server."
      (cons lsp-purescript-server-executable
	    lsp-purescript-server-args))
  #+end_src

  The full command we want to run is
  #+begin_src bash :tangle no
    nix-shell --run 'yarn purescript-language-server --stdio'
  #+end_src

  So we'll override the first two of the relevent variables
  #+begin_src emacs-lisp :tangle no
    (setq lsp-purescript-server-executable "nix-shell")
    (setq lsp-purescript-server-args '("--run" "'yarn purescript-language-server --stdio'"))
  #+end_src

  But that didn't work. It just immediately exits with no info. I
  don't know why.

  So I can run this one instead one instead, which implies we're in a
  nix-shell.

  #+begin_src emacs-lisp
    (setq lsp-purescript-server-executable "yarn")
    (setq lsp-purescript-server-args '("purescript-language-server" "--stdio"))
  #+end_src


  Note that this (obviously) requires the purescript-language-server
  package to be installed through yarn, plus it requires
  purescript. Both of the following should succeed (in the nix shell):
  #+begin_src bash :tangle no
    yarn purescript-language-server
    purs ide # this is what the the above command wraps
  #+end_src

** pscide integration attempt
   this method fails in this way: https://github.com/purescript-emacs/psc-ide-emacs/issues/189
   #+begin_src emacs-lisp :tangle no
     (use-package purescript-mode :ensure t)
     (use-package psc-ide :ensure t)
     (add-hook 'purescript-mode-hook
       (lambda ()
	 (psc-ide-mode)
	 (company-mode)
	 (flycheck-mode)
	 (turn-on-purescript-indentation)))
   #+end_src

   Apparently it's the result of json-encoding-pretty-print being set
   to true, but I'm still going to leave this off for now because the
   LSP-mode is working fine.
* language server protocol
  this is used by several different language modes
  #+begin_src emacs-lisp
	(use-package lsp-mode :ensure t)
  #+end_src

  by default this uses Super in the prefix key, which I'm aleady using
  for xmonad

  #+begin_src emacs-lisp
	(setq lsp-keymap-prefix "C-c l")
  #+end_src
* term-alert

  These commands provide wrappers around the term-alert.el package,
  which allows for an alert to be sent after commands complete in term-mode.

#+BEGIN_SRC emacs-lisp
  (use-package "term-alert" :ensure t)
#+END_SRC

  Define two notification commands. They are both expecting to be run in
  a terminal mode. `term-alert-function` should be a buffer local
  variable, so these set it each time they're called.

#+BEGIN_SRC emacs-lisp
  (defun sms-alert-on-cmd-completion ()
    (interactive)
    (setq term-alert-function 'gf/sms-notify-term-alert)
    (term-alert-next-command-toggle 1))

  (defun email-alert-on-cmd-completion ()
    (interactive)
    (setq term-alert-function 'gf/email-notify-term-alert)
    (term-alert-next-command-toggle 1))

#+END_SRC

  Functions to be wrapped in the above commands.

#+BEGIN_SRC emacs-lisp
  (defun gf/email-notify-term-alert ()
      (mail)
      (mail-to) (insert goose/email)      ; my email address
      (mail-subject) (insert "[EMACS] command completion")
      (mail-send)
      (kill-this-buffer))

  (defun gf/sms-notify-term-alert ()
    (gf/sms-notification "Term command completed."))
#+END_SRC

* javascript

  set indentation to 2 spaces
#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)
#+END_SRC

  start flycheck in javascript
#+BEGIN_SRC emacs-lisp
  (add-hook 'js2-mode-hook 'flycheck-mode)
#+END_SRC

  use smartparens mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'js2-mode-hook 'smartparens-strict-mode)
#+END_SRC


use js2-mode instead of javascript mode
#+BEGIN_SRC emacs-lisp
  (add-to-list
     'auto-mode-alist
     `(,(rx ".js$") . js2-mode))
#+END_SRC

* haskell

Since intero-mode has been end-of-lifed, i'm trying out dante.

#+BEGIN_SRC emacs-lisp
  (use-package dante
  :ensure t
  :after haskell-mode
  :commands 'dante-mode
  :init
  (add-hook 'haskell-mode-hook 'flycheck-mode)
  (add-hook 'haskell-mode-hook 'dante-mode)
  (add-hook 'haskell-mode-hook (lambda ()
                                 (setq dante-tap-type-time 1)
                                 )))


#+END_SRC

(setq dante-methods-alist (cons
                                                            '(nix-no-net dante-cabal-nix ("nix-shell" "--no-substitute" "--run" (concat "cabal v1-repl " (or dante-target "") " --builddir=dist/dante")))
                                                            dante-methods-alist))

** previously on...

Intero-mode is a nice nigh-IDE for haskell. But don't start it
automatically in haskell files b/c sometimes it can require quite a
bit of setup.

# #+BEGIN_SRC emacs-lisp
#   (use-package "intero" :ensure t)
# #+END_SRC

* Scala

generic scala mode, not super useful.

#+BEGIN_SRC emacs-lisp
  (use-package "scala-mode" :ensure t)
#+END_SRC

* elm
- install elm mode
- (add-to-list 'company-backends 'company-elm)
- look into ensure that elm-oracle is installed
* java

  tried out meghanada, but it was preventing saves and giving me other issues.
** meghanada
   Experimenting with this mode.

   The following are from https://github.com/mopemope/meghanada-emacs/blob/master/README.md

  meghanada-mode interfaces with a meghanada server, similar to
  intero-mode for haskell (I'm assuming). but loading the java repos
  at work basically crashes emacs
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package "meghanada" :ensure t)
#+END_SRC

dependencies of meghanada. Specified here: https://github.com/mopemope/meghanada-emacs
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package "cl-lib" :ensure t)
  (use-package "yasnippet" :ensure t)
  (use-package "company" :ensure t)
  (use-package "flycheck" :ensure t)
#+END_SRC

the next code block does the following:
- use meghanada in java-mode
- enable flycheck
- set indentation levels
- set locations of java and maven
- autoformat code on save

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'java-mode-hook
       (lambda ()
	 (meghanada-mode t)
	 (flycheck-mode +1)
	 (setq c-basic-offset 4)
	 (setq meghanada-java-path "java")
	 (setq meghanada-maven-path "mvn")
	 ;; (add-hook 'before-save-hook 'meghanada-code-beautify-before-save)
	 ))
#+END_SRC

** java lsp
   set up java lsp mode
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package "lsp-mode" :ensure t)
     (use-package "company-lsp" :ensure t)
     (use-package "lsp-ui" :ensure t)
     (use-package "lsp-java" :ensure t)

     (add-hook 'java-mode-hook 'lsp)
     (add-hook 'java-mode-hook 'flycheck-mode)
     (add-hook 'java-mode-hook 'company-mode)
   #+END_SRC

   i've basically given in to intellij for java at work.

* python

  use a whitespace mode with python and convert tabs to spaces on saving
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook
            (lambda ()
              (setq leerzeichen-line-feed-glyph (make-glyph-code ?  'leerzeichen))
              (leerzeichen-mode 't)
              ;; (add-hook 'before-save-hook (lambda ( ) (tabify (point-min) (point-max) 't)) nil 'local)
              ))

#+END_SRC

* json

pretty print json files
#+BEGIN_SRC emacs-lisp
  (setq json-encoding-pretty-print t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq json-reformat:indent-width 2)
#+END_SRC

* git

  Set the magit bindings recommended in the magit tutorial
#+BEGIN_SRC emacs-lisp
  (use-package "magit" :ensure t)
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

require package for manipulating github pull requests from within
magit. This started causing magit-status to fail to be able to open
the minibuffer, so I've disabled it for the time being.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package "forge" :ensure t)
#+END_SRC

* RSS

use elfeed for rss, and elfeed-org to organize rss feeds in an org
file
#+BEGIN_SRC emacs-lisp
  (use-package "elfeed" :ensure t)
  (use-package "elfeed-org" :ensure t)
#+END_SRC

Initialize elfeed-org. This hooks up elfeed-org to read the configuration when elfeed
is started with `M-x elfeed`
#+BEGIN_SRC emacs-lisp
(elfeed-org)
#+END_SRC

Specify a number of files containing elfeed configuration. If not set
then the location below is used. Note: The customize interface is also
supported.
#+BEGIN_SRC emacs-lisp
(setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
#+END_SRC

* eshell

  eshell can mess up some commands that are expecting piped input. Add
  them to this list if they don't work as expected with pipes.

  #+BEGIN_SRC emacs-lisp
    (eval-after-load "esh-proc" '(add-to-list 'eshell-needs-pipe "entr"))
  #+END_SRC
* Twilio sms

  Ensure that the json.el package is present, which the request.el
  library uses to parse json responses.
  #+BEGIN_SRC emacs-lisp
    (use-package "json" :ensure t)
  #+END_SRC

  Ensure that the request-deferred.el package is present, which wraps
  request.el in a deferred function from deferred.el
  #+BEGIN_SRC emacs-lisp
    (use-package "request-deferred" :ensure t)
  #+END_SRC

  Helper function used to generate the string expected by the
  authentication header in using http basic authenticaiton.
#+BEGIN_SRC emacs-lisp
  (defun gf/build-auth-hash (username password)
    (concat "Basic " (base64-encode-string (concat username ":" password) t)))
#+END_SRC

  Core function that sends a request to the Twilio API. `sid` and
  `token` must be aquired from [[www.twilio.com][Twilio]], and
  `from-phone` must be verified.
#+BEGIN_SRC emacs-lisp
  (defun gf/twilio-send-text (sid token from-phone to-phone msg)
    (deferred:$
      (request-deferred (concat "https://api.twilio.com/2010-04-01/Accounts/" sid "/Messages.json")
                        :parser 'json-read
                        :data `((To . ,to-phone)
                                (From . ,from-phone)
                                (Body . ,msg))
                        :headers `((authorization . ,(gf/build-auth-hash sid token))))
      (deferred:nextc it
        (lambda (raw-response)
          (let* ((response (request-response-data raw-response))
                 (status (request-response-symbol-status raw-response))
                 (oopsie (request-response-error-thrown raw-response))
                 (err-msg (cdr (assoc 'message response))))
            (if oopsie (message "Twilio connection error: %S, %S" oopsie err-msg)
              (message "Twilio SMS status: %S" status)))))
      (deferred:error it
        (lambda (err)
          (message "Request error: %S" err)))))


#+END_SRC

  Command wrapping the `gf/twilio-send-text` function. Queries user in
  minibuffer for a phone number and message to send an SMS
  message.
  #+BEGIN_SRC emacs-lisp
    (defun send-sms ()
      (interactive)
      (let ((to-phone (read-from-minibuffer "Recipient's phone number: "))
            (msg (read-from-minibuffer "Text message: ")))
        (gf/twilio-send-text env/twilio-sid
                             env/twilio-token
                             env/from-phone
                             to-phone
                             msg)))
  #+END_SRC

   Generic command for sending an sms message to `env/my-phone`

  #+BEGIN_SRC emacs-lisp
    (defun gf/sms-notification (msg)
      (gf/twilio-send-text env/twilio-sid
                           env/twilio-token
                           env/from-phone
                           env/my-phone
                           msg))

  #+END_SRC

* custom functions

I wrote this because I missed Vi's "o" button which would create an
empty line below the current one, and jump to it without breaking the
current line. I may be duplicating some existing emacs command here.
#+BEGIN_SRC emacs-lisp
  (defun jump-to-newline ()
      "Move to the end of the current line, then create a newline.
  \(Like \"o\" in Vi.\) I'm probably replicating a pre-existing command."
      (interactive)
      (move-end-of-line nil)
      (newline)
      (indent-for-tab-command))
#+END_SRC

I got this function from:
http://ergoemacs.org/emacs/emacs_byte_compile.html
** org-mode spreadsheet helper functions
I wrote these functions to help with calculating my work hours and
wages in an org-mode spreadsheet. I needed these to help calculate
values in spreadsheet cells.

Adds up the minutes in hh:mm formatted time string.
#+BEGIN_SRC emacs-lisp :results silent
  (defun to-minutes (time-string)
    "Accepts a string of format '(h)h:mm' and returns total minutes"
    (string-match "\\([0-9]+\\):\\([0-9]\\{2,\\}\\)" time-string)
    (let ((hours (string-to-number (match-string 1 time-string)))
          (minutes (string-to-number (match-string 2 time-string))))
      (if (> minutes 59)
          (error (concat (number-to-string minutes) " is not between 0 and 59"))
        (+ minutes (* hours 60)))))
#+END_SRC

Takes a float representing minutes, and returns an hh:mm formatted
string.
#+BEGIN_SRC emacs-lisp :results silent
  (defun number-to-time (number)
    "Converts a float into formatted string (hh:mm)"
    (let ((hours (/ number 60))
          (minutes (% number 60)))
      (concat (format "%d" hours)
              ":"
              (format "%02d" minutes))))
#+END_SRC

Takes a list of times in the hh:mm format, and returns a sum in the same
format
#+BEGIN_SRC emacs-lisp :results silent
  (defun sum-times (time-list)
    "Takes a list of times (hh:mm), and returns sum in the same format (hh:mm)"
    (number-to-time (apply '+ (mapcar 'to-minutes time-list))))
#+END_SRC

Takes a hh:mm formatted time string, converts it to total minutes, and
  then multiplies it by an hourly rate. Returns a string formatted
  like dollars but without the "$" (because org-mode cannot read from
  a spreadsheet cell starting with "$")
#+BEGIN_SRC emacs-lisp :results silent
  (defun time-to-wage (time dollars-per-hour)
    "Converts time (hh:mm) to wages."
    (let ((minutes (to-minutes time)))
      (let ((hours (/ minutes
                      60.0)))
        (format "%0.2f" (* hours dollars-per-hour)))))
#+END_SRC

Converts a float into dollar format ($0.00)
#+BEGIN_SRC emacs-lisp :results silent
  (defun number-to-dollars (float)
    "Formats float into dollar string"
    (format "$%0.2f" float))
#+END_SRC

* novelty functions
  These were the first functions I wrote, while reading the built-in
  emacs lisp tutorial. A friend of mine loves the table-flipping meme,
  but hates emacs. So I decided to write the table-flipping meme into
  emacs.

(╯°□°)╯︵ ┻━┻
I started with this basic table-flipping character. Passing an
argument will specify how long to pause before flipping.
#+BEGIN_SRC emacs-lisp
  (defun flip-table (num)
    "Animates flipping a table."
    (interactive "p")
    (let ((start-point (point))
          (anticipation (or num 4)))
      (insert "(°-°) ┬─┬ ")
      (sit-for anticipation)
      (delete-region start-point (point))
      (insert "(╯°□°)╯︵ ┻━┻ ")))
#+END_SRC

flip-pɹoʍ︵\(°□°\)
My next function flips the last word before the cursor. A couple
required functions are also included.
#+BEGIN_SRC emacs-lisp
  (defun flip-word (num)
    "Animates flipping the last word."
    (interactive "p")
      (let ((anticipation (or num 4)))
        (re-search-backward "\\(\\<\\w+\\>[.,!?]?\\)")
        (goto-char (match-end 0))
        (insert " (°-°)")
        (let ((post-face (point)))
          (sit-for anticipation)
          (replace-match (rotate-word (match-string-no-properties 0)))
          (delete-region (match-end 0) post-face))
        (insert "︵\\(°□°\\) ")))

  (defun rotate-word (string)
    (let ((flipped))
      (dolist (ascii-dec (string-to-list string))
        (setq flipped (cons
                       (unicode-to-char
                        (dec-to-upside-down-unicode ascii-dec))
                       flipped)))
      (concat flipped)))

  ;; used in rotate-word
  (defun unicode-to-char (unicode)
    (string-to-number unicode 16))

  ;; used in rotate-word
  (defun dec-to-upside-down-unicode (dec)
    (cond ((= dec 97) "0250")
          ((= dec 98) "0071")
          ((= dec 99) "0254")
          ((= dec 100) "0070")
          ((= dec 101) "01dd")
          ((= dec 102) "025f")
          ((= dec 103) "0253")
          ((= dec 104) "0265")
          ((= dec 105) "0131")
          ((= dec 106) "027e")
          ((= dec 107) "029e")
          ((= dec 108) "006c")
          ((= dec 109) "026f")
          ((= dec 110) "0075")
          ((= dec 111) "006f")
          ((= dec 112) "0064")
          ((= dec 113) "0062")
          ((= dec 114) "0279")
          ((= dec 115) "0073")
          ((= dec 116) "0287")
          ((= dec 117) "006e")
          ((= dec 118) "028c")
          ((= dec 119) "028d")
          ((= dec 120) "0078")
          ((= dec 121) "028e")
          ((= dec 122) "007a")
          ((= dec 65) "2200")
          ((= dec 66) "10412")
          ((= dec 67) "0186")
          ((= dec 68) "15e1")
          ((= dec 69) "018e")
          ((= dec 70) "2132")
          ((= dec 71) "2141")
          ((= dec 72) "0048")
          ((= dec 73) "0049")
          ((= dec 74) "017f")
          ((= dec 75) "029e")
          ((= dec 76) "2142")
          ((= dec 77) "0057")
          ((= dec 78) "004e")
          ((= dec 79) "004f")
          ((= dec 80) "0500")
          ((= dec 81) "038c")
          ((= dec 82) "1d1a")
          ((= dec 83) "0053")
          ((= dec 84) "22a5")
          ((= dec 85) "2229")
          ((= dec 86) "039b")
          ((= dec 87) "004d")
          ((= dec 88) "0058")
          ((= dec 89) "2144")
          ((= dec 90) "005a")
          ((= dec 48) "0030")
          ((= dec 49) "21c2")
          ((= dec 50) "218a")
          ((= dec 51) "218b")
          ((= dec 52) "3123")
          ((= dec 53) "078e")
          ((= dec 54) "0039")
          ((= dec 55) "3125")
          ((= dec 56) "0038")
          ((= dec 57) "0036")
          ((= dec 38) "214b")
          ((= dec 45) "203e")
          ((= dec 63) "00bf")
          ((= dec 33) "00a1")
          ((= dec 34) "201e")
          ((= dec 39) "002c")
          ((= dec 46) "02d9")
          ((= dec 44) "0027")
          ((= dec 59) "061b")
          (t nil)))
#+END_SRC
